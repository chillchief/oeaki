<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>おえかき30ページ</title>
<link rel="icon" type="image/svg+xml" href="icons/favicon.svg">
</head>
<body>
<style>
  :root { color-scheme: light dark; }
  body { margin:0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP"; background:#f6f7f9; }
  header { background:#1f2937; color:#fff; padding:10px 12px; display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  header .title { font-weight:600; margin-right:8px; }
  button, .pagebtn, .seg button, a.btn {
    padding:10px 14px; border-radius:10px; border:1px solid #64748b40; background:#fff; cursor:pointer; color:#111; text-decoration:none;
    touch-action:manipulation; /* タブレットの連続タップ遅延を抑制 */
  }
  .seg button { min-width:40px; } /* 押しやすい幅 */
  button.primary, .seg button.primary, a.btn.primary { background:#3b82f6; color:#fff; border-color:#3b82f6; }
  button:disabled { opacity:.6; cursor:not-allowed; }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .row.right { margin-left:auto; }
  .seg { display:inline-flex; gap:6px; }
  .label { color:#e5e7eb; font-size:13px; }
  main { display:grid; grid-template-columns: 1fr; gap:10px; padding:10px; }
  .canvas-wrap { display:flex; justify-content:center; }
  canvas#canvas { background:#fff; border:1px solid #e5e7eb; border-radius:8px; touch-action:none; }
  .pages { display:flex; gap:8px; padding:8px 10px 10px; overflow-x:auto; white-space:nowrap; -webkit-overflow-scrolling:touch; background:#f1f5f9; border-bottom:1px solid #e5e7eb; }
  .hidden { display:none !important; }
  .pagebtn { background:transparent; border:none; padding:0; display:inline-grid; gap:4px; justify-items:center; }
  .thumb { width:96px; height:72px; border:1px solid #e5e7eb; border-radius:6px; background:#fff; display:block; }
  .pnum { font-size:12px; color:#334155; }
  .pagebtn.active .thumb { outline:2px solid #3b82f6; outline-offset:0; }
  #bar { height:10px; background:#e5e7eb; border-radius:999px; overflow:hidden; width:320px; }
  #fill { height:100%; width:0%; background:#3b82f6; }
  #status { min-height:1.2em; font-size:13px; color:#374151; text-align:center; }
  #err { color:#b91c1c; font-size:12px; white-space:pre-wrap; text-align:center; }
  .spacer { flex:1; }
  input[type="range"] { width:160px; }
</style>

<header>
  <div class="title">おえかき 30ページ</div>

  <!-- 基本ツール -->
  <div class="row">
    <button id="penBtn" class="primary">ペン</button>
    <button id="eraserBtn">消しゴム</button>
    <button id="undoBtn">戻る</button>
    <button id="clearPageBtn">全消去</button>
    <button id="copyPrevBtn" title="前ページの内容をこのページへコピー">前ページをコピー</button>
  </div>

  <!-- 太さ（タブレット対応の押しやすいボタン） -->
  <div class="row">
    <span class="label">ペン太さ</span>
    <div class="seg" id="penSizeSeg">
      <button data-size="small">小</button>
      <button data-size="medium" class="primary">中</button>
      <button data-size="large">大</button>
    </div>
    <span class="label">消しゴム</span>
    <div class="seg" id="eraserSizeSeg">
      <button data-size="small">小</button>
      <button data-size="medium" class="primary">中</button>
      <button data-size="large">大</button>
    </div>
  </div>

  <!-- レイヤー／不透明度 -->
  <div class="row">
    <span class="label">レイヤー</span>
    <div class="seg" id="layerSeg">
      <button data-layer="0" class="primary">L1</button>
      <button data-layer="1">L2</button>
      <button data-layer="2">L3</button>
    </div>
    <span class="label">不透明度</span>
    <input id="opacityRange" type="range" min="0" max="100" value="100">
    <span id="opacityVal" class="label">100%</span>
  </div>

  <!-- 遅延 -->
  <div class="row">
    <span class="label">遅延(ms)</span>
    <input id="delayMs" type="number" min="10" step="10" value="100" style="width:6em;">
  </div>

  <!-- 右寄せ操作 -->
  <div class="row right">
    <button id="pngAllBtn" class="primary">PNG一括（全ページ）</button>
    <button id="playBtn">▶︎ プレビュー</button>
    <button id="toggleThumbsBtn">サムネ非表示</button>
    <a class="btn" href="images2mp4.html" target="_blank" rel="noopener noreferrer">画像→MP4ページへ</a>
  </div>

  <div class="spacer"></div>

  <!-- ページ移動 -->
  <div class="row" style="margin-left:auto">
    <button id="prevBtn">← 前</button>
    <div id="pageLabel">ページ 1 / 30</div>
    <button id="nextBtn">次 →</button>
  </div>
</header>

<div class="pages" id="pages"></div>

<main>
  <div class="canvas-wrap">
    <canvas id="canvas" width="640" height="480"></canvas>
  </div>
  <div class="row" style="justify-content:center; gap:12px;">
    <div id="bar"><div id="fill"></div></div>
    <div id="pct" style="width:60px; text-align:right;">0%</div>
  </div>
  <div id="status"></div>
  <div id="err"></div>
</main>

<script>
/* ========= 定数・状態 ========= */
const CANVAS_W = 640, CANVAS_H = 480;
const PAGE_COUNT = 30;
const LAYER_COUNT = 3;
const UNDO_LIMIT = 20;
const TH_W = 96, TH_H = 72;

// 太さプリセット
const PEN_SIZES    = { small: 2,  medium: 4,  large: 8  };
const ERASER_SIZES = { small: 12, medium: 18, large: 26 };
let penSizeKey = 'medium';
let eraserSizeKey = 'medium';

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const pagesBar   = document.getElementById('pages');
const pageLabel  = document.getElementById('pageLabel');
const statusEl   = document.getElementById('status');
const errEl      = document.getElementById('err');
const fill       = document.getElementById('fill');
const pct        = document.getElementById('pct');
const delayInput = document.getElementById('delayMs');
const opacityRange = document.getElementById('opacityRange');
const opacityVal   = document.getElementById('opacityVal');

let drawing=false, erasing=false, last=null;
let currentPage = 0;
let activeLayer = 0;

// ページ別データ（レイヤー・不透明度・Undo）
const pages = Array.from({length: PAGE_COUNT}, () => ({
  layers: Array.from({length: LAYER_COUNT}, ()=> null),
  opacity: Array.from({length: LAYER_COUNT}, ()=> 1),
  undos:  Array.from({length: LAYER_COUNT}, ()=> []),
  dirty: false,
  thumbEl: null
}));

// プレビュー
let isPreview = false;
let previewTimer = null;
let previewFrames = [];
let previewIndex = 0;
let previewBackup = { pageIndex: 0, image: null };

/* ========= 初期化 ========= */
initCanvas();
buildPageThumbnails();
renderCurrentPage();
bindUI();
updatePageUI();
updateThumb(0);

function initCanvas(){
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,canvas.width,canvas.height);
}
function ensureLayer(pageIndex, layerIndex){
  const p = pages[pageIndex];
  if(!p.layers[layerIndex]){
    const cvs = document.createElement('canvas');
    cvs.width = CANVAS_W; cvs.height = CANVAS_H;
    const c = cvs.getContext('2d');
    p.layers[layerIndex] = { cvs, ctx: c };
  }
  return p.layers[layerIndex];
}

/* ========= サムネ ========= */
function buildPageThumbnails(){
  for(let i=0;i<PAGE_COUNT;i++){
    const btn = document.createElement('button');
    btn.className = 'pagebtn' + (i===0 ? ' active' : '');
    const th = document.createElement('canvas');
    th.className = 'thumb';
    th.width = TH_W; th.height = TH_H;
    const num = document.createElement('div');
    num.className = 'pnum';
    num.textContent = (i+1);
    btn.append(th, num);
    btn.addEventListener('click', ()=> switchPage(i), {passive:true});
    pagesBar.appendChild(btn);
    pages[i].thumbEl = th;
    const tctx = th.getContext('2d'); tctx.fillStyle = '#fff'; tctx.fillRect(0,0,TH_W,TH_H);
  }
}

/* ========= UIイベント ========= */
function bindUI(){
  document.getElementById('penBtn').addEventListener('click', ()=>{ erasing=false; setToolActive('penBtn'); }, {passive:true});
  document.getElementById('eraserBtn').addEventListener('click', ()=>{ erasing=true;  setToolActive('eraserBtn'); }, {passive:true});
  document.getElementById('undoBtn').addEventListener('click', ()=>{ if(!isPreview){ undo(); updateThumb(currentPage); } }, {passive:true});
  document.getElementById('clearPageBtn').addEventListener('click', ()=>{ if(!isPreview){ pushSnapshot(); clearPage(currentPage); } }, {passive:true});
  document.getElementById('copyPrevBtn').addEventListener('click', copyFromPreviousPage, {passive:true});
  document.getElementById('prevBtn').addEventListener('click', ()=>{ if(!isPreview) switchPage(Math.max(0, currentPage-1)); }, {passive:true});
  document.getElementById('nextBtn').addEventListener('click', ()=>{ if(!isPreview) switchPage(Math.min(PAGE_COUNT-1, currentPage+1)); }, {passive:true});

  document.getElementById('pngAllBtn').addEventListener('click', ()=> exportAllPNGs(), {passive:true});

  document.getElementById('toggleThumbsBtn').addEventListener('click', ()=>{
    const hidden = pagesBar.classList.toggle('hidden');
    document.getElementById('toggleThumbsBtn').textContent = hidden ? 'サムネ表示' : 'サムネ非表示';
  }, {passive:true});

  // レイヤー選択
  document.querySelectorAll('#layerSeg button').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      document.querySelectorAll('#layerSeg button').forEach(b=> b.classList.remove('primary'));
      btn.classList.add('primary');
      activeLayer = parseInt(btn.dataset.layer, 10);
      const op = pages[currentPage].opacity[activeLayer] ?? 1;
      opacityRange.value = Math.round(op*100);
      opacityVal.textContent = `${Math.round(op*100)}%`;
    }, {passive:true});
  });

  // 不透明度
  opacityRange.addEventListener('input', ()=>{
    const v = Math.max(0, Math.min(100, parseInt(opacityRange.value,10) || 100));
    pages[currentPage].opacity[activeLayer] = v/100;
    opacityVal.textContent = `${v}%`;
    renderCurrentPage();
    updateThumb(currentPage);
  }, {passive:true});

  // ★ 太さセグメント（タブレットで確実に押せるボタン）
  bindSizeSeg('penSizeSeg',  (size)=>{ penSizeKey    = size; /* ペン選択中なら見た目だけ更新 */ });
  bindSizeSeg('eraserSizeSeg',(size)=>{ eraserSizeKey = size; /* 消しゴム選択中なら見た目だけ更新 */ });

  // プレビュー
  const playBtn = document.getElementById('playBtn');
  playBtn.addEventListener('click', ()=> isPreview ? stopPreview() : startPreview(), {passive:true});

  // 描画
  canvas.addEventListener('pointerdown', (e)=>{
    if(isPreview) return;
    e.preventDefault();
    canvas.setPointerCapture(e.pointerId);
    drawing = true;
    last = getPos(e);
    pushSnapshot();
  });
  canvas.addEventListener('pointermove', (e)=>{
    if(!drawing || isPreview) return;
    const p = getPos(e);
    const layer = ensureLayer(currentPage, activeLayer);
    const lctx = layer.ctx;
    lctx.lineWidth = erasing ? ERASER_SIZES[eraserSizeKey] : PEN_SIZES[penSizeKey];
    lctx.lineCap = 'round'; lctx.lineJoin = 'round';
    lctx.strokeStyle = '#000';
    lctx.globalCompositeOperation = erasing ? 'destination-out' : 'source-over';
    lctx.beginPath(); lctx.moveTo(last.x,last.y); lctx.lineTo(p.x,p.y); lctx.stroke();
    lctx.globalCompositeOperation = 'source-over';
    last = p;
    pages[currentPage].dirty = true;
    renderCurrentPage();
  });
  ['pointerup','pointercancel','pointerleave'].forEach(ev => canvas.addEventListener(ev, ()=>{
    if(!drawing) return;
    drawing=false; last=null;
    updateThumb(currentPage);
  }));

  // Undoショートカット / Esc停止
  window.addEventListener('keydown', (e)=>{
    const isUndoKey = (e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase()==='z';
    if(isUndoKey && !isPreview){ e.preventDefault(); undo(); updateThumb(currentPage); }
    if(e.key === 'Escape' && isPreview){ e.preventDefault(); stopPreview(); }
  });

  updateCopyPrevButton();
}

function bindSizeSeg(id, onChange){
  const seg = document.getElementById(id);
  seg.querySelectorAll('button').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      seg.querySelectorAll('button').forEach(b=> b.classList.remove('primary'));
      btn.classList.add('primary');
      onChange(btn.dataset.size);
    }, {passive:true});
  });
}

function setToolActive(id){
  ['penBtn','eraserBtn'].forEach(x=>document.getElementById(x).classList.remove('primary'));
  document.getElementById(id).classList.add('primary');
}
function getPos(e){ const r = canvas.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }

/* ========= ページ切替/表示 ========= */
function switchPage(i){
  if(i===currentPage) return;
  updateThumb(currentPage);
  currentPage = i;
  updatePageUI();
  const op = pages[currentPage].opacity[activeLayer] ?? 1;
  opacityRange.value = Math.round(op*100);
  opacityVal.textContent = `${Math.round(op*100)}%`;
  renderCurrentPage();
  updateCopyPrevButton();
}
function updatePageUI(){
  pageLabel.textContent = `ページ ${currentPage+1} / ${PAGE_COUNT}`;
  Array.from(pagesBar.children).forEach((btn,idx)=> btn.classList.toggle('active', idx===currentPage));
}

/* ========= 合成描画 ========= */
function renderCurrentPage(){
  ctx.save();
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = 'source-over';
  ctx.fillStyle = '#fff'; ctx.fillRect(0,0,canvas.width,canvas.height);

  const p = pages[currentPage];
  for(let li=0; li<LAYER_COUNT; li++){
    const layer = p.layers[li];
    const alpha = p.opacity[li] ?? 1;
    if(layer && alpha>0){
      ctx.globalAlpha = alpha;
      ctx.drawImage(layer.cvs, 0, 0);
    }
  }
  ctx.restore();
}

/* ========= サムネ ========= */
function updateThumb(index){
  const th = pages[index]?.thumbEl; if(!th) return;
  const tctx = th.getContext('2d');
  tctx.fillStyle = '#fff'; tctx.fillRect(0,0,TH_W,TH_H);

  const tmp = document.createElement('canvas'); tmp.width = CANVAS_W; tmp.height = CANVAS_H;
  const c = tmp.getContext('2d');
  c.fillStyle = '#fff'; c.fillRect(0,0,CANVAS_W,CANVAS_H);
  const p = pages[index];
  for(let li=0; li<LAYER_COUNT; li++){
    const layer = p.layers[li];
    const alpha = p.opacity[li] ?? 1;
    if(layer && alpha>0){
      c.globalAlpha = alpha;
      c.drawImage(layer.cvs, 0, 0);
    }
  }
  tctx.imageSmoothingEnabled = true; tctx.imageSmoothingQuality = 'high';
  tctx.drawImage(tmp, 0, 0, TH_W, TH_H);
}

/* ========= 前ページコピー ========= */
function updateCopyPrevButton(){
  const btn = document.getElementById('copyPrevBtn');
  btn.disabled = currentPage === 0;
}
function copyFromPreviousPage(){
  if(currentPage === 0) return;
  const src = pages[currentPage - 1];
  const dst = pages[currentPage];

  // 全レイヤーのスナップショットを積む（Undo可）
  for(let li=0; li<LAYER_COUNT; li++){
    const dLayer = ensureLayer(currentPage, li);
    const stack = dst.undos[li];
    try{
      const snap = dLayer.ctx.getImageData(0,0,CANVAS_W,CANVAS_H);
      if(stack.length>=UNDO_LIMIT) stack.shift();
      stack.push(snap);
    }catch(e){}
  }

  for(let li=0; li<LAYER_COUNT; li++){
    const dLayer = ensureLayer(currentPage, li);
    dLayer.ctx.clearRect(0,0,CANVAS_W,CANVAS_H);
    const sLayer = src.layers[li];
    if(sLayer){ dLayer.ctx.drawImage(sLayer.cvs, 0, 0); }
    dst.opacity[li] = src.opacity[li] ?? 1;
  }
  dst.dirty = true;
  renderCurrentPage();
  updateThumb(currentPage);
}

/* ========= 全消去 ========= */
function clearPage(i){
  const p = pages[i];
  // Undo用スナップショット
  for(let li=0; li<LAYER_COUNT; li++){
    const layer = ensureLayer(i, li);
    const stack = p.undos[li];
    try{
      const snap = layer.ctx.getImageData(0,0,CANVAS_W,CANVAS_H);
      if(stack.length>=UNDO_LIMIT) stack.shift();
      stack.push(snap);
    }catch(e){}
  }
  for(let li=0; li<LAYER_COUNT; li++){
    const layer = p.layers[li];
    if(layer){ layer.ctx.clearRect(0,0,CANVAS_W,CANVAS_H); }
  }
  p.dirty = false;
  renderCurrentPage();
  updateThumb(i);
}

/* ========= Undo（ページ×レイヤー） ========= */
function pushSnapshot(){
  try{
    const layer = ensureLayer(currentPage, activeLayer);
    const snap = layer.ctx.getImageData(0,0,CANVAS_W,CANVAS_H);
    const stack = pages[currentPage].undos[activeLayer];
    if(stack.length>=UNDO_LIMIT) stack.shift();
    stack.push(snap);
  }catch(e){}
}
function undo(){
  const stack = pages[currentPage].undos[activeLayer];
  if(!stack || !stack.length) return;
  const last = stack.pop();
  const layer = ensureLayer(currentPage, activeLayer);
  try{ layer.ctx.putImageData(last, 0, 0); }catch(e){}
  renderCurrentPage();
}

/* ========= プレビュー ========= */
function startPreview(){
  previewFrames = [];
  for(let i=0;i<PAGE_COUNT;i++){
    const p = pages[i];
    for(let li=0; li<LAYER_COUNT; li++){
      if(p.layers[li]){ previewFrames.push(i); break; }
    }
  }
  if(previewFrames.length===0){ status('描画のあるページがありません（プレビューできません）'); return; }
  try{ previewBackup.image = ctx.getImageData(0,0,canvas.width,canvas.height); }catch{}
  previewBackup.pageIndex = currentPage;

  setEditingEnabled(false); isPreview = true; previewIndex = 0;
  document.getElementById('playBtn').textContent = '■ 停止'; status('プレビュー再生中…');
  renderPreviewFrame(); previewTimer = setInterval(renderPreviewFrame, getDelay());
}
function renderPreviewFrame(){
  const idx = previewFrames[previewIndex];
  Array.from(pagesBar.children).forEach((b, i)=> b.classList.toggle('active', i===idx));
  pageLabel.textContent = `ページ ${idx+1} / ${PAGE_COUNT}`;
  const p = pages[idx];
  ctx.fillStyle = '#fff'; ctx.fillRect(0,0,canvas.width,canvas.height);
  for(let li=0; li<LAYER_COUNT; li++){
    const layer = p.layers[li];
    const alpha = p.opacity[li] ?? 1;
    if(layer && alpha>0){ ctx.globalAlpha = alpha; ctx.drawImage(layer.cvs, 0, 0); }
  }
  ctx.globalAlpha = 1;
  previewIndex = (previewIndex + 1) % previewFrames.length;
}
function stopPreview(){
  if(!isPreview) return;
  clearInterval(previewTimer); previewTimer = null; isPreview = false;
  document.getElementById('playBtn').textContent = '▶︎ プレビュー';
  try{ if(previewBackup.image) ctx.putImageData(previewBackup.image,0,0); }catch{}
  renderCurrentPage();
  setEditingEnabled(true);
  status('プレビュー停止');
}

/* ========= PNG一括（ZIP） ========= */
async function exportAllPNGs(){
  if(isPreview) return;
  resetProgress(); clearError();
  status('全ページをPNG化してZIP作成中…');
  setEditingEnabled(false);

  const out = document.createElement('canvas'); const octx = out.getContext('2d');
  out.width = CANVAS_W; out.height = CANVAS_H;

  const zip = new JSZip();
  for(let i=0;i<PAGE_COUNT;i++){
    octx.clearRect(0,0,CANVAS_W,CANVAS_H);
    octx.fillStyle = '#ffffff'; octx.fillRect(0,0,CANVAS_W,CANVAS_H);
    const p = pages[i];
    for(let li=0; li<LAYER_COUNT; li++){
      const layer = p.layers[li];
      const alpha = p.opacity[li] ?? 1;
      if(layer && alpha>0){ octx.globalAlpha = alpha; octx.drawImage(layer.cvs, 0, 0); }
    }
    octx.globalAlpha = 1;
    const blob = await canvasToBlob(out, 'image/png');
    zip.file(`page-${String(i+1).padStart(2,'0')}.png`, blob);
    progress((i+1)/PAGE_COUNT);
    status(`PNG作成中… ${i+1}/${PAGE_COUNT}`);
    await microtask();
  }
  status('ZIP を生成中…');
  const blobZip = await zip.generateAsync({ type:'blob' }, (meta)=>{ progress(meta.percent/100); });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blobZip);
  a.download = `oeaki-pages.zip`;
  a.click();
  setTimeout(()=> URL.revokeObjectURL(a.href), 10000);
  status('ZIPのダウンロードを開始しました。');
  setEditingEnabled(true);
}

function canvasToBlob(c, type='image/png'){
  return new Promise(resolve=>{
    if(c.toBlob){ c.toBlob(b=> resolve(b), type); }
    else{
      const dataURL = c.toDataURL(type);
      const byteString = atob(dataURL.split(',')[1]);
      const mime = dataURL.split(',')[0].match(/:(.*?);/)[1];
      const ab = new ArrayBuffer(byteString.length);
      const ia = new Uint8Array(ab);
      for(let i=0;i<byteString.length;i++) ia[i]=byteString.charCodeAt(i);
      resolve(new Blob([ab], {type:mime}));
    }
  });
}

/* ========= UI補助 ========= */
function setEditingEnabled(enabled){
  [
    'penBtn','eraserBtn','undoBtn','clearPageBtn',
    'copyPrevBtn','prevBtn','nextBtn',
    'pngAllBtn','toggleThumbsBtn'
  ].forEach(id => {
    const el = document.getElementById(id);
    if(el) el.disabled = !enabled;
  });
  document.getElementById('playBtn').disabled = false;
  delayInput.disabled = !enabled;
  opacityRange.disabled = !enabled;
  document.querySelectorAll('#layerSeg button, #penSizeSeg button, #eraserSizeSeg button')
    .forEach(b=> b.disabled = !enabled);
}
function resetProgress(){ fill.style.width='0%'; pct.textContent='0%'; }
function progress(p){ const v=Math.max(0,Math.min(1,p)); fill.style.width=(v*100).toFixed(0)+'%'; pct.textContent=(v*100).toFixed(0)+'%'; }
function status(t){ statusEl.textContent = t; }
function clearError(){ errEl.textContent=''; }
function logError(t){ errEl.textContent += (t+'\n'); }
function microtask(){ return new Promise(r=>setTimeout(r,0)); }
function getDelay(){ const n = parseInt(delayInput.value, 10); return Number.isFinite(n) ? Math.max(10, n) : 100; }
</script>

<!-- ZIP生成ライブラリ -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</body>
</html>
