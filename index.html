<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>お絵かき（Pointer + Undo）</title>
  <style>
    body { margin:0; background:#eee; }
    header { background:#333; color:#fff; padding:10px; }
    .toolbar button { margin-right:8px; padding:6px 12px; }
    canvas { background:#fff; display:block; width:100vw; height:90vh; touch-action:none; }
  </style>
</head>
<body>
  <header>
    <div class="toolbar">
      <button id="penBtn">ペン</button>
      <button id="eraserBtn">消しゴム</button>
      <button id="undoBtn">戻る</button>
      <button id="clearBtn">全消去</button>
      <button id="saveBtn">PNG保存</button>
    </div>
  </header>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // ---- Undo 用 ----
    const undoStack = [];
    const UNDO_LIMIT = 50;

    let drawing = false, erasing = false, last = null;

    function resize() {
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight * 0.9;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.lineWidth = 4;
      // 背景を白で塗る（保存時に透明にならないように）
      ctx.save();
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
      undoStack.length = 0; // サイズが変わるため履歴はクリア
    }
    window.addEventListener('resize', resize);
    resize();

    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }

    // ---- 履歴 ----
    function pushSnapshot() {
      try {
        const snap = ctx.getImageData(0, 0, canvas.width, canvas.height);
        if (undoStack.length >= UNDO_LIMIT) undoStack.shift();
        undoStack.push(snap);
      } catch (err) {
        console.warn('スナップショット取得に失敗:', err);
      }
    }
    function undo() {
      if (undoStack.length === 0) return;
      try {
        const prev = undoStack.pop();
        ctx.putImageData(prev, 0, 0);
      } catch (err) {
        console.warn('Undo失敗:', err);
      }
    }

    // ---- Pointer 対応（マウス/タッチ/Apple Pencil 共通）----
    canvas.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      canvas.setPointerCapture(e.pointerId);
      drawing = true;
      last = getPos(e);
      pushSnapshot(); // ストローク開始前に履歴を積む
    });

    canvas.addEventListener('pointermove', (e) => {
      if (!drawing) return;
      const p = getPos(e);
      ctx.strokeStyle = erasing ? "#fff" : "#000";
      // （必要なら筆圧対応） const w = erasing ? 18 : (4 + (e.pressure || 0)*2); ctx.lineWidth = w;
      ctx.beginPath();
      ctx.moveTo(last.x, last.y);
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
      last = p;
    });

    function stopDraw() { drawing = false; last = null; }
    canvas.addEventListener('pointerup', stopDraw);
    canvas.addEventListener('pointercancel', stopDraw);
    canvas.addEventListener('pointerleave', stopDraw);

    // ---- ボタン ----
    document.getElementById('penBtn').onclick    = () => erasing = false;
    document.getElementById('eraserBtn').onclick  = () => erasing = true;
    document.getElementById('undoBtn').onclick    = () => undo();

    document.getElementById('clearBtn').onclick = () => {
      pushSnapshot();
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.save(); ctx.fillStyle = "#fff"; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore();
    };

    document.getElementById('saveBtn').onclick = () => {
      const a = document.createElement('a');
      a.download = 'drawing.png';
      a.href = canvas.toDataURL('image/png');
      a.click();
    };

    // ---- ショートカット（Ctrl/Cmd + Z）----
    window.addEventListener('keydown', (e) => {
      const isUndo = (e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 'z';
      if (isUndo) { e.preventDefault(); undo(); }
    });
  </script>
</body>
</html>
