<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>お絵かき（Undo対応）</title>
  <style>
    body { margin:0; background:#eee; }
    header { background:#333; color:#fff; padding:10px; }
    .toolbar button { margin-right:8px; padding:6px 12px; }
    canvas { background:#fff; display:block; width:100vw; height:90vh; touch-action:none; }
  </style>
</head>
<body>
  <header>
    <div class="toolbar">
      <button id="penBtn">ペン</button>
      <button id="eraserBtn">消しゴム</button>
      <button id="undoBtn">戻る</button>
      <button id="clearBtn">全消去</button>
      <button id="saveBtn">PNG保存</button>
    </div>
  </header>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // ---- Undo/Redo 用（今回は Undo のみ使用）----
    const undoStack = [];
    const redoStack = [];
    const UNDO_LIMIT = 50; // 履歴の上限（メモリ対策）

    let drawing = false, erasing = false, last = null;

    function resize() {
      // ※リサイズすると画像サイズが変わるため履歴をクリアします
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight * 0.9;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.lineWidth = 4;

      // 背景を白で初期化（保存画像が透明にならないように）
      ctx.save();
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();

      // 初期状態は履歴なし（最初の描画時にスナップショットを取ります）
      undoStack.length = 0;
      redoStack.length = 0;
    }
    window.addEventListener('resize', resize);
    resize();

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }

    // ---- 履歴操作 ----
    function pushSnapshot() {
      // 現在キャンバスをスナップショットして積む
      try {
        const snap = ctx.getImageData(0, 0, canvas.width, canvas.height);
        if (undoStack.length >= UNDO_LIMIT) undoStack.shift();
        undoStack.push(snap);
        // Undoのたびにやり直し履歴は破棄（今回はRedoボタンなし）
        redoStack.length = 0;
      } catch (err) {
        console.warn('スナップショット取得に失敗:', err);
      }
    }

    function undo() {
      if (undoStack.length === 0) return;
      try {
        // 現在状態を redoStack に退避（将来Redo対応する場合に備え）
        const current = ctx.getImageData(0, 0, canvas.width, canvas.height);
        redoStack.push(current);

        const prev = undoStack.pop();
        ctx.putImageData(prev, 0, 0);
      } catch (err) {
        console.warn('Undoに失敗:', err);
      }
    }

    // ---- マウス操作（シンプル実装）----
    canvas.addEventListener('mousedown', e => {
      drawing = true;
      last = getMousePos(e);
      // ストローク開始時にスナップショットを保存
      pushSnapshot();
    });
    canvas.addEventListener('mouseup', () => { drawing = false; });
    canvas.addEventListener('mouseleave', () => { drawing = false; });

    canvas.addEventListener('mousemove', e => {
      if (!drawing) return;
      const p = getMousePos(e);
      ctx.strokeStyle = erasing ? "#fff" : "#000";
      ctx.beginPath();
      ctx.moveTo(last.x, last.y);
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
      last = p;
    });

    // ---- ボタン ----
    document.g
